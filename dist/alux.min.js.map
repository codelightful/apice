{"version":3,"file":"alux.min.js","sources":["../src/util.mjs","../src/cookies.mjs","../src/logging.mjs","../src/errorHandler.mjs","../src/http.mjs","../src/controller.mjs","../src/fragment.mjs","../src/router.mjs","../src/components/toast.mjs","../src/components/ui.mjs","../src/alux.mjs"],"sourcesContent":["const $module = {};\r\nconst $scope = {};\r\n\r\n// NOTE: this module is a low level module and should not import any other module\r\n\r\n//-----------------------------------------------------------------------------\r\n// ALUX ELEMENT\r\n//-----------------------------------------------------------------------------\r\n/** Hold the singleton instances of unique DOM elements (body, window) */\r\n$scope.singletons = {};\r\n\r\n/** Class wrapping a DOM element and simplifying some actions on it */\r\nclass AluxElement {\r\n\t#element;\r\n\tconstructor(element) {\r\n\t\tthis.#element = element;\r\n\t}\r\n\r\n\t/** Allows to obtain the number of effective DOM elements covered by this instance */\r\n\tget count() {\r\n\t\tif (!this.#element) {\r\n\t\t\treturn 0;\r\n\t\t} else if (Array.isArray(this.#element)) {\r\n\t\t\treturn this.#element.length;\r\n\t\t}\r\n\t\treturn 1;\r\n\t}\r\n\r\n\t/**\r\n\t * Allows to obtain or set the HTML content of an element.  If no paramaters are provided the html content will\r\n\t * be returned.  When a string argument is provided, the HTML content of the element will be set with the string.\r\n\t * When a AluxElement is provided, then the HTML content will be extracted from it.  If a reference to a DOM element\r\n\t * is provided, then it will be set as the content of the wrapped element.\r\n\t * @returns When no argument are provided returns the HTML element otherwise returns the AluxElement instance\r\n\t */\r\n\thtml() {\r\n\t\tif (arguments.length === 0) {\r\n\t\t\tif (!this.#element) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\t// TODO: what to do if we have an array of elements\r\n\t\t\treturn this.#element.innerHTML;\r\n\t\t}\r\n\t\tif (!this.#element) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tvar content = arguments[0];\r\n\t\tif (!content) {\r\n\t\t\tthis.#element.innerHTML = '';\r\n\t\t} else if (typeof (content) === 'string') {\r\n\t\t\tthis.#element.innerHTML = content;\r\n\t\t} else if (content instanceof AluxElement) {\r\n\t\t\tthis.#element.innerHTML = content.html();\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\ton(eventName, fnc) {\r\n\t\tif (!eventName) {\r\n\t\t\tthrow new Error('alux.element.on.no_event_name');\r\n\t\t}\r\n\t\tif (this.#element && typeof (fnc) === 'function') {\r\n\t\t\t$module.events.addListener(this.#element, eventName, fnc);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n}\r\n\r\n/**\r\n * Allows to obtain an Alux element as a wrapper for a particular DOM element\r\n * @param selector String with the selector to obtain the DOM element or reference to the DOM element\r\n * @returns An AluxElement wrapping the element. If the element does not exist an empty AluxElement will be returned.\r\n */\r\n$module.element = function (selector) {\r\n\tif (!selector || selector === 'body') {\r\n\t\tif (!$scope.singletons.body) {\r\n\t\t\t$scope.singletons.body = new AluxElement(document.body);\r\n\t\t}\r\n\t\treturn $scope.singletons.body;\r\n\t} else if (selector === 'window') {\r\n\t\tif (!$scope.singletons.window) {\r\n\t\t\t$scope.singletons.window = new AluxElement(window);\r\n\t\t}\r\n\t\treturn $scope.singletons.window;\r\n\t} else if (selector instanceof AluxElement) {\r\n\t\treturn selector;\r\n\t}\r\n\tconst selectorType = typeof (selector);\r\n\tif (selectorType === 'string') {\r\n\t\tvar element = document.querySelector(selector);\r\n\t\treturn new AluxElement(element);\r\n\t} else if (selectorType === 'object') {\r\n\t\t// TODO evaluate it is really a DOM element\r\n\t\treturn new AluxElement(selector);\r\n\t}\r\n\treturn new AluxElement();\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// EVENT HANDLING\r\n//-----------------------------------------------------------------------------\r\n$module.events = {};\r\n// placeholders to maintain references to event listeners and callbacks\r\n$scope.events = {};\r\n// contains all the callbacks registered to be executed once the ready status is reached\r\n$scope.events.ready = {\r\n\tcompleted: false,\r\n\tlisteners: []\r\n};\r\n// allows to determine if the checkready state has been executed\r\n$scope.events.checkReadyState = false;\r\n\r\nfunction onEvent(eventName, fnc) {\r\n\tconst eventHolder = $scope.events[eventName];\r\n\tif (!eventHolder) {\r\n\t\tthrow new Error('alux.events.unknown_event[' + eventName + ']');\r\n\t} else if (typeof (fnc) !== 'function') {\r\n\t\tthrow new Error('alux.events.invalid_listener');\r\n\t} else if (eventHolder.completed) {\r\n\t\tfnc();\r\n\t} else {\r\n\t\teventHolder.listeners.push(fnc);\r\n\t}\r\n}\r\n\r\n/**\r\n * Allows to register a callback to be executed when the document ready state has been reached\r\n * @param fnc Function to be executed when the document ready is reached\r\n */\r\n$module.events.onReady = function (fnc) {\r\n\tonEvent('ready', fnc);\r\n\tif ($scope.events.checkReadyState) {\r\n\t\treturn;\r\n\t}\r\n\t$scope.events.checkReadyState = true;\r\n\tconst onDocumentReady = () => {\r\n\t\t$scope.events.ready.completed = true;\r\n\t\tif ($scope.events.ready.listeners.length > 0) {\r\n\t\t\t$scope.events.ready.listeners.map((handler) => {\r\n\t\t\t\thandler();\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n\tif (document.readyState === \"complete\") {\r\n\t\tonDocumentReady();\r\n\t} else if (typeof (document.addEventListener) === 'function') {\r\n\t\tdocument.addEventListener('DOMContentLoaded', onDocumentReady, false);\r\n\t} else if (typeof (document.attachEvent) === 'function') {\r\n\t\tdocument.attachEvent(\"onreadystatechange\", function () {\r\n\t\t\tif (document.readyState === \"complete\") {\r\n\t\t\t\tonDocumentReady();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n};\r\n\r\n/**\r\n * Adds an event listener to a specific element\r\n * @param target Reference to the DOM element that will receive the event listener\r\n * @param eventName Name of the event, for example 'click'\r\n * @param fnc Function to be executed when the event is triggered\r\n */\r\n$module.events.addListener = function (target, eventName, fnc) {\r\n\tif (!target) {\r\n\t\tthrow new Error('alux.util.event.invalid_target');\r\n\t} else if (!eventName || typeof (eventName) !== 'string') {\r\n\t\tthrow new Error('alux.util.event.invalid_event_name');\r\n\t} else if (typeof (fnc) !== 'function') {\r\n\t\treturn;\r\n\t}\r\n\tif (typeof(target.addEventListener) === 'function') {\r\n\t\ttarget.addEventListener(eventName, fnc, false);\r\n\t} else if (typeof(target.attachEvent) === 'function') {\r\n\t\ttarget.attachEvent('on' + eventName, fnc);\r\n\t}\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// OBJECT EVALUATION\r\n//-----------------------------------------------------------------------------\r\n/**\r\n * Allows to determine if a specific object instance is a promise or not\r\n * @param target Object instance to evaluate\r\n * @returns Boolean value to determine if the object instance is a promise or not\r\n */\r\n$module.isPromise = function (target) {\r\n\treturn (target instanceof Promise);\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// STRIING MANIPULATION\r\n//-----------------------------------------------------------------------------\r\n/** Trims a string by removing leading and trailing white spaces  */\r\n$module.trim = function (text) {\r\n\treturn text.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// RANDOM\r\n//-----------------------------------------------------------------------------\r\n$module.random = {};\r\n\r\n/** Creates a random tiny identified composed by 4 alphanumeric characters */\r\n$module.random.tinyId = function () {\r\n\treturn (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\r\n};\r\n\r\n/** Creates a random short identified composed by 8 alphanumeric characters */\r\n$module.random.shortId = function () {\r\n\treturn $module.random.tinyId() + $module.random.tinyId();\r\n};\r\n\r\n/** Creates a random values simulating a global global unique identifier */\r\n$module.random.guid = function () {\r\n\treturn $module.random.shortId()\r\n\t\t+ '-' + $module.random.shortId()\r\n\t\t+ '-' + $module.random.shortId()\r\n\t\t+ '-' + $module.random.shortId()\r\n\t\t+ $module.random.shortId();\r\n};\r\n\r\nexport default $module;","const $module = {};\r\n\r\nimport util from './util.mjs';\r\n\r\n/**\r\n * Sets a specific cookie\r\n * @param name Name of the cookie to set\r\n * @param value Value to set\r\n * @param timespan Timspan to maintain the cookie in seconds\r\n */\r\n$module.set = function(name, value, timespan) {\r\n    if(typeof(name) !== 'string') {\r\n        throw new Error('alux.cookies.set.invalid_name');\r\n    } else if (typeof (timespan) !== 'number') {\r\n        throw new Error('alux.cookies.set.invalid_timespan');\r\n    }\r\n    const expireDate = new Date();\r\n    expireDate.setTime(expireDate.getTime() + (timespan * 1000));\r\n    var cookie = util.trim(name) + '=' + value + '; expires=' + expireDate.toGMTString() + '; path=/';\r\n    document.cookie = cookie;\r\n};\r\n\r\n/**\r\n * Obtains the value from a cookie\r\n * @param name Name of the cookie to obtain\r\n * @returns Cookie value or null if it is not defined\r\n */\r\n$module.get = function(name) {\r\n    if(typeof(name) !== 'string') {\r\n        throw new Error('alux.cookies.get.invalid_name');\r\n    }\r\n    const cookieArray = document.cookie.split(';');\r\n    var cookieValue = null;\r\n    for(var idx=0; idx < cookieArray.length; idx++) {\r\n        const rawCookie = util.trim(cookieArray[idx]);\r\n        if(!rawCookie) {\r\n            continue;\r\n        }\r\n        const cookieParts = rawCookie.split('=');\r\n        if(util.trim(cookieParts[0]) !== name) {\r\n            continue;\r\n        }\r\n        return cookieParts[1];\r\n    }\r\n    return null;\r\n};\r\n\r\nexport default $module;","/*\r\nAlux Logger Module\r\nv1.0.0\r\n*/\r\nconst $module = {};\r\nconst $scope = {};\r\n\r\n// contains all the loggers registered\r\n$scope.loggers = {};\r\n// dictionary with all the defined log levels\r\n$scope.levels = {\r\n    fatal: { value: 10, color: '#ff4444', label: 'FATAL' },\r\n    error: { value: 20, color: '#ff4444', label: 'ERROR' },\r\n    warn: { value: 30, color: '#ff8800', label: 'WARNING' },\r\n    info: { value: 40, color: '#0099cc', label: 'INFO' },\r\n    debug: { value: 50, color: '#3E4551', label: 'DEBUG' },\r\n    trace: { value: 60, color: '#3E4551', label: 'TRACE' }\r\n};\r\n\r\nimport cookies from './cookies.mjs';\r\nvar levelCookie = cookies.get('alux.logger.level');\r\nif(!levelCookie) {\r\n    $scope.globalLevel = $scope.levels.warn;\r\n} else {\r\n    $scope.globalLevel = $scope.levels[levelCookie];\r\n    if(!$scope.globalLevel) {\r\n        $scope.globalLevel = $scope.levels.warn;\r\n    }\r\n}\r\n\r\n/**\r\n * Internal log implementation\r\n * @param logName Name of the logger to print\r\n * @param currentLevel Log level defined for the logger\r\n * @param level Level of the log message to print\r\n * @param message Message to print\r\n * @param details Details to add\r\n */\r\nfunction log(logName, currentLevel, level, message, ...details) {\r\n    if(currentLevel.value >= level.value) {\r\n        console.log('%c[' + level.label + '][' + logName + ']: ' + message, ...['color: ' + level.color, ...details]);\r\n    }\r\n};\r\n\r\n/** Represents a specific logger */\r\nclass Logger {\r\n    // holds the name or identigier of the current logger\r\n    #name;\r\n    // log level defined for the logger instance\r\n    #level;\r\n\r\n    constructor(name) {\r\n        this.#name = name;\r\n        var levelCookie = cookies.get('alux.logger.[' + name + '].level');\r\n        if(!levelCookie) {\r\n            this.#level = $scope.globalLevel;\r\n        } else {\r\n            this.#level = $scope.levels[levelCookie];\r\n            if(!this.#level) {\r\n                this.#level = $scope.globalLevel;\r\n            }       \r\n        }\r\n    }\r\n\r\n    /** Obtains or sets the log level defined for the logger instance */\r\n    level() {\r\n        if(arguments.length !== 0) {\r\n            var levelInfo = $scope.levels[arguments[0]];\r\n            if(!levelInfo) {\r\n                throw new Error('alux.logger.invalid_level[' + arguments[0] + ']');\r\n            }\r\n            this.#level = levelInfo;\r\n            cookies.set('alux.logger.[' + this.#name + '].level', arguments[0], 1800);\r\n        }\r\n        return this.#level.label;\r\n    }\r\n\r\n    /**\r\n     * Prints a FATAL log message\r\n     * @param message Message to print\r\n     * @param details Objects to add as details to the logger\r\n     */\r\n    fatal(message, ...details) {\r\n        log(this.#name, this.#level, $scope.levels.fatal, message, ...details);\r\n    }\r\n\r\n    /**\r\n     * Prints an ERROR log message\r\n     * @param message Message to print\r\n     * @param details Objects to add as details to the logger\r\n     */\r\n    error(message, ...details) {\r\n        log(this.#name, this.#level, $scope.levels.error, message, ...details);\r\n    }\r\n\r\n    /**\r\n     * Prints a WARNING log message\r\n     * @param message Message to print\r\n     * @param details Objects to add as details to the logger\r\n     */\r\n    warn(message, ...details) {\r\n        log(this.#name, this.#level, $scope.levels.warn, message, ...details);\r\n    }\r\n\r\n    /**\r\n     * Prints an INFO log message\r\n     * @param message Message to print\r\n     * @param details Objects to add as details to the logger\r\n     */\r\n    info(message, ...details) {\r\n        log(this.#name, this.#level, $scope.levels.info, message, ...details);\r\n    }\r\n\r\n    /**\r\n     * Prints a DEBUG log message\r\n     * @param message Message to print\r\n     * @param details Objects to add as details to the logger\r\n     */\r\n    debug(message, ...details) {\r\n        log(this.#name, this.#level, $scope.levels.debug, message, ...details);\r\n    }\r\n\r\n    /**\r\n     * Prints a TRACE log message\r\n     * @param message Message to print\r\n     * @param details Objects to add as details to the logger\r\n     */\r\n    trace(message, ...details) {\r\n        log(this.#name, this.#level, $scope.levels.trace, message, ...details);\r\n    }\r\n}\r\n\r\n/**\r\n * Obtains the instance of a specific logger or creates a new one if that does not exist\r\n * @param name Logger name or identifier\r\n * @returns Logger instance\r\n */\r\n$module.getLogger = function(name) {\r\n    if(!$scope.loggers[name]) {\r\n        $scope.loggers[name] = new Logger(name);\r\n    }\r\n    return $scope.loggers[name];\r\n};\r\n\r\n/** Gets or sets the default level defined for the loggers */\r\n$module.level = function() {\r\n    if(arguments.length === 1) {\r\n        const levelInfo = $scope.levels[arguments[0]];\r\n        if(!levelInfo) {\r\n            throw new Error('alux.logger.invalid_level[' + arguments[0] + ']');\r\n        }\r\n        $scope.globalLevel = levelInfo;\r\n        cookies.set('alux.logger.level', arguments[0], 1800);\r\n        for(var logName in $scope.loggers) {\r\n            var logger = $scope.loggers[logName];\r\n            logger.level(arguments[0]);\r\n        }\r\n    } else if(arguments.length === 2) {\r\n        const logger = $module.getLogger(arguments[0]);\r\n        logger.level(arguments[1]);\r\n        return logger.level();\r\n    }\r\n    return $scope.globalLevel?.label;\r\n};\r\n\r\nexport default $module;","const $module = {};\r\nimport log from './logging.mjs';\r\nimport util from './util.mjs';\r\n\r\n/** Wrapper that allows to control the action around an error */\r\nclass ErrorHandler {\r\n    // String with the name of the module or the layer that produced the error. This is used to obtain the logger\r\n    #module\r\n    // String with the message to show to the user (if any). When there is no specific message, then a generic error message will be shown\r\n    #message\r\n    // The cause of the error (if any)\r\n    #cause\r\n    // The code of the error (if any). This wil be printed to the log as a hint, along with the cause (if any)\r\n    #code\r\n    // The unique error number used to correlate any error message in the UI with the entries in the log\r\n    #guid\r\n\r\n    constructor(specs) {\r\n        this.#guid = util.random.guid();\r\n        this.#message = specs.message;\r\n        this.#cause = specs.cause;\r\n        this.#module = specs.module;\r\n        this.#code = specs.code ?? 'alux.error_handler';\r\n    }\r\n\r\n    /** Allows to obtain the unique value that identify this error occurrence */\r\n    get guid() {\r\n        return this.#guid;\r\n    }\r\n\r\n    /** Obtains the message if there is any */\r\n    get message() {\r\n        return this.#message??'An error has occurred. Please contact the technical support without closing this screen.';\r\n    }\r\n\r\n    /** Obtains the cause if there is any */\r\n    get cause() {\r\n        return this.#cause;\r\n    }\r\n\r\n    /** Obtains the error code if any */\r\n    get code() {\r\n        return this.#code;\r\n    }\r\n\r\n    /** Creates an error entry with the details about the error */\r\n    log() {\r\n        const logger = log.getLogger(this.#module);\r\n        // TODO: improve this algorithm\r\n        if(typeof(this.#cause) === 'string') {\r\n            logger.error('[' + this.#guid + ']\\n-> ' + this.#code + '\\n-> ' + this.#cause);\r\n        } else if(this.#cause) {\r\n            if(this.#cause instanceof ErrorHandler) {\r\n                if(this.#cause.code && this.#cause.cause) {\r\n                    logger.error('[' + this.#guid + ']\\n-> ' + this.#code + '\\n-> ' + this.#cause.code + '\\n->', this.#cause.cause);\r\n                } else if(this.#cause.code) {\r\n                    logger.error('[' + this.#guid + ']\\n-> ' + this.#code + '\\n-> ' + this.#cause.code);\r\n                } else if(this.#cause.cause) {\r\n                    logger.error('[' + this.#guid + ']\\n-> ' + this.#code + '\\n->', this.#cause.cause);\r\n                }\r\n                // TODO: handle nested error handlers\r\n            } else if(this.#cause instanceof HttpError) {\r\n                logger.error('[' + this.#guid + ']\\n-> ' + this.#code + '\\n-> http-error[' + this.#cause.code + ']');\r\n            } else {\r\n                logger.error('[' + this.#guid + ']\\n-> ' + this.#code + '\\n->', this.#cause);\r\n            }\r\n        } else {\r\n            logger.error('[' + this.#guid + ']\\n-> ' + this.#code);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders a visual hint to inform the user about the error\r\n     * @param selector String with the selector to render the error on it or reference to a DOM element\r\n     */\r\n    render(selector) {\r\n        var target = util.element(selector);\r\n        this.log();\r\n        target.html('<div class=\"badge badge-error\">\\\r\n            <div class=\"header\">Atention!</div>\\\r\n            <div class=\"content\">' + this.message + '</div>\\\r\n            <div class=\"details\">' + this.#guid + '</div>\\\r\n        </div>');\r\n    }\r\n}\r\n\r\n/**\r\n * Creates an object to wrap an error and allow to take actions with it\r\n * @param specs Object with the specifications to create the error handler.  The values are:\r\n *      - module: String with the name of the module that produces the error (required)\r\n *      - message: String with any message rendered to the end user (optional)\r\n *      - cause: Reference to the root cause that creates the error condition (optional if the cause is provided)\r\n *      - code: String with the error code (optional if a code is provided)\r\n * @returns Error hanlder instance\r\n */\r\n$module.create = function(specs) {\r\n    return new ErrorHandler(specs);\r\n};\r\n\r\n/**\r\n * Renders a visual hint to report an error. This method is polymorphic and can receive:\r\n * 1) A selector and a error object: The error will be rendered inside the element matching the selector.\r\n *    The selector can be a string or a reference to a DOM element.\r\n *    The error can be a JavaScript error, an ErrorHandler reference or a specification object (see below)\r\n * 2) A error object: The error will be rendered in the body.\r\n *    The error can be a JavaScript error, an ErrorHandler reference or a specification object (see below)\r\n * When the error is a specification object please follow the structured defined in the create method of this module\r\n */\r\n$module.render = function() {\r\n    var err = null;\r\n    var selector = null;\r\n    if(arguments.length === 1) {\r\n        err = arguments[0];\r\n    } else if(arguments.length === 2) {\r\n        selector = arguments[0];\r\n        err = arguments[1];\r\n    }\r\n    if(!err) {\r\n        return;\r\n    } else if(!(err instanceof ErrorHandler)) {\r\n        err = new ErrorHandler(err);\r\n    }\r\n    err.render(selector);\r\n};\r\n\r\n/** Represents an HTTP error */\r\nclass HttpError {\r\n    /** Code of the HTTP error */\r\n    #code;\r\n    \r\n    /**\r\n     * Creates a new HttpError instance with a specific error code\r\n     * @param code HTTP error code\r\n     */\r\n    constructor(code) {\r\n        this.#code = code;\r\n    }\r\n\r\n    /** Code with the type of error */\r\n    get type() {\r\n        return 'http';\r\n    }\r\n\r\n    /** Allows to obtain the HTTP code associated with the error represented by this instance */\r\n    get code() {\r\n        return this.#code;\r\n    }\r\n}\r\n\r\n/** Creates an HTTP error */\r\n$module.createHttpError = function(httpCode) {\r\n    return new HttpError(httpCode);\r\n};\r\n\r\nexport default $module;","const $module = {};\r\nconst $moduleName = 'alux.http';\r\n\r\nimport errorHandler from './errorHandler.mjs';\r\n\r\n/** Creates the underlying XMLHTTP object used to execute ajax calls */\r\nfunction createXmlHttp() {\r\n\tif (window.XMLHttpRequest) {\r\n\t\treturn new XMLHttpRequest();\r\n\t} else {\r\n\t\ttry {\r\n\t\t\treturn new ActiveXObject('Msxml2.XMLHTTP');\r\n\t\t} catch (e) {\r\n\t\t\ttry {\r\n\t\t\t\treturn new ActiveXObject('Microsoft.XMLHTTP');\r\n\t\t\t} catch (ex) {\r\n\t\t\t\tthrow Error('alux.http.xmlhttp_creation_error');\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/** Create a request object to execute ajax calls in a crossbrowser approach */\r\nfunction createRequest(resolve, reject) {\r\n\tconst request = createXmlHttp();\r\n\trequest.onreadystatechange = function () {\r\n\t\tif (request.readyState == 4 || request.readyState === 'complete') {\r\n\t\t\tif (request.status == 200) {\r\n\t\t\t\tresolve(request.responseText);\r\n\t\t\t} else {\r\n\t\t\t\treject(errorHandler.createHttpError(request.status));\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn request;\r\n}\r\n\r\n/**\r\n * \r\n * @param url String with the resource URL to be requested\r\n * @param options Object with the options to execute the request. The values are:\r\n * \t\t\t\t\t- method: String with the HTTP method to execute: GET, POST, PUT, DELETE. If this is not provided, GET will be used by default.\r\n * \t\t\t\t\t- async: Boolean value to determine if the request should be asynchronous (true) or not. By default it is true.\r\n *                  - data: Data to be included in a POST, PUT or DELETE request\r\n * @returns \r\n */\r\n$module.request = function (url, options) {\r\n\tif (typeof (url) !== 'string' || !url) {\r\n\t\tthrow new Error('alux.http.null_url');\r\n\t}\r\n\tif (!options) {\r\n\t\toptions = {};\r\n\t}\r\n\tif (!options.method) {\r\n\t\toptions.method = 'GET';\r\n\t}\r\n\t// TODO: add headers\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tconst request = createRequest(resolve, reject);\r\n\t\trequest.open(options.method, url, options.async !== false);\r\n\t\tif (options.method === 'GET' || !options.data) {\r\n\t\t\trequest.send();\r\n\t\t} else {\r\n\t\t\trequest.send(options.data);\r\n\t\t}\r\n\r\n\t});\r\n};\r\n\r\n/**\r\n * Loads a JavaScript resource dynamically\r\n * @param url URL to load the script from it\r\n * @returns Promise that allows to handle the script loading actions\r\n */\r\n$module.loadScript = function (url) {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tvar element = document.createElement('script');\r\n\t\telement.src = url;\r\n\t\telement.type = 'text/javascript';\r\n\t\telement.async = false;\r\n\t\telement.onerror = () => {\r\n\t\t\treject(errorHandler.create({\r\n\t\t\t\tmodule: $moduleName,\r\n\t\t\t\tcode: 'alux.http.load_script_error[' + url + ']'\r\n\t\t\t})); // TODO: collect error info\r\n\t\t};\r\n\t\telement.onload = () => {\r\n\t\t\tresolve();\r\n\t\t};\r\n\t\tdocument.head.appendChild(element);\r\n\t});\r\n};\r\n\r\n/** Class representing a URL assembled with different parts */\r\nclass AluxUrl {\r\n\t// string with the HTTP protocol (http, https)\r\n\t#protocol\r\n\t// String wit the host name\r\n\t#host\r\n\t// String with the port\r\n\t#port\r\n\t// String with the resource path\r\n\t#path\r\n\r\n\t/**\r\n\t * Creates a new instance representing a url by providing its parts\r\n\t * @param protocol String with the HTTP protocol to use (http, https) or null to use https as default\r\n\t * @param host String with the host name. This parameter is mandatory, when is not ptovided an error will be throw\r\n\t * @param port String with the port number or null to use port 80 as the default one\r\n\t * @param path String with the base path or null to use the root\r\n\t */\r\n\tconstructor(protocol, host, port, path) {\r\n\t\tif (!this.#host) {\r\n\t\t\tthrow new Error('alux.http.url.no_host');\r\n\t\t}\r\n\t\tthis.#protocol = protocol ?? 'https';\r\n\t\tthis.#host = host;\r\n\t\tthis.#port = port ?? '80';\r\n\t\tthis.#path = this.#path ?? '';\r\n\t}\r\n\r\n\t/** Obtains the HTTP protocol used by the url */\r\n\tget protocol() {\r\n\t\treturn this.#protocol;\r\n\t}\r\n\r\n\t/** Obtains the host used by the url */\r\n\tget host() {\r\n\t\treturn this.#host;\r\n\t}\r\n\r\n\t/** Obtains the port used by the url */\r\n\tget port() {\r\n\t\treturn this.#port;\r\n\t}\r\n\r\n\t/** Obtains the base path used by the url */\r\n\tget path() {\r\n\t\treturn this.#path;\r\n\t}\r\n\r\n\t/** Creates a string representation of this url */\r\n\ttoString() {\r\n\t\treturn this.#protocol + '://' + this.#host + ':' + this.#port + '/' + this.#path;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a url string using the base url represented by this instance and concatenating additional elements\r\n\t * @param path String with the path of an additional resource to be added to the base url represented by this instance or null to ignore it.\r\n\t * @param query Query string to add to the base URL represented by this instance or null to ignore it.\r\n\t * @param hash Hash to add to the base URL represented by this instance or null to ignore it.\r\n\t * @returns String with a full url\r\n\t */\r\n\tresourceUrl(path, query, hash) {\r\n\t\tvar url = this.toString();\r\n\t\tif (path && typeof (path) === 'string') {\r\n\t\t\tif (!url.endsWith('/') && !path.startsWith('/')) {\r\n\t\t\t\turl += '/';\r\n\t\t\t}\r\n\t\t\turl += path;\r\n\t\t}\r\n\t\tif (query && typeof (query) === 'string') {\r\n\t\t\tif (!query.startsWith('?')) {\r\n\t\t\t\turl += '?';\r\n\t\t\t}\r\n\t\t\turl += query;\r\n\t\t}\r\n\t\tif (hash && typeof (hash) === 'string') {\r\n\t\t\tif (!hash.startsWith('#')) {\r\n\t\t\t\turl += '#';\r\n\t\t\t}\r\n\t\t\turl += hash;\r\n\t\t}\r\n\t\treturn url;\r\n\t}\r\n\r\n\t/**\r\n\t * Executes an HTTP GET operation using the URL represented by this instance and adding additional elements\r\n\t * @param path Resource path to add to the base url represented by this instance or null to maintain the original \r\n\t * @param query Query string to add to the base URL represented by this instance\r\n\t * @param hash Hash to add to the base url represented by this instance\r\n\t * @returns A promise to capture the execution of the HTTP request\r\n\t */\r\n\tget(path, query, hash) {\r\n\t\tvar url = this.resourceUrl(path, query, hash);\r\n\t\treturn $module.request(url, { method: 'GET' });\r\n\t}\r\n\r\n\t/**\r\n\t * Executes an HTTP POST operation using the URL represented by this instance and adding a resource path and data\r\n\t * @param path Resource path to add to the base url represented by this instance or null to maintain the original \r\n\t * @param data Object to post as data in the HTTP request\r\n\t * @returns A promise to capture the execution of the HTTP request\r\n\t */\r\n\tpost(path, data) {\r\n\t\tvar url = this.resourceUrl(path);\r\n\t\treturn $module.request(url, { method: 'POST', data: data });\r\n\t}\r\n\r\n\t/**\r\n\t * Executes an HTTP PUT operation using the URL represented by this instance and adding a resource path and data\r\n\t * @param path Resource path to add to the base url represented by this instance or null to maintain the original \r\n\t * @param data Object to post as data in the HTTP request\r\n\t * @returns A promise to capture the execution of the HTTP request\r\n\t */\r\n\tput(path, data) {\r\n\t\tvar url = this.resourceUrl(path);\r\n\t\treturn $module.request(url, { method: 'PUT', data: data });\r\n\t}\r\n\r\n\t/**\r\n\t * Executes an HTTP DELETE operation using the URL represented by this instance and adding a resource path and data\r\n\t * @param path Resource path to add to the base url represented by this instance or null to maintain the original \r\n\t * @param data Object to post as data in the HTTP request\r\n\t * @returns A promise to capture the execution of the HTTP request\r\n\t */\r\n\tdelete(path, data) {\r\n\t\tvar url = this.resourceUrl(path);\r\n\t\treturn $module.request(url, { method: 'DELETE', data: data });\r\n\t}\r\n}\r\n\r\nclass UrlBuilder {\r\n\t// string with the HTTP protocol (http, https)\r\n\t#protocol\r\n\t// String wit the host name\r\n\t#host\r\n\t// String with the port\r\n\t#port\r\n\t// String with the resource path\r\n\t#path\r\n\r\n\t/**\r\n\t * Defines the HTTP protocol to be used by the url\r\n\t * @param protocol String with the protocol. Example: https\r\n\t * @returns Fluent instance to continue the build\r\n\t */\r\n\tprotocol(protocol) {\r\n\t\tthis.#protocol = protocol;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Defines the name of the host to be used in the url to be build\r\n\t * @param host String with the hostname\r\n\t * @returns Fluent instance to continue the build\r\n\t */\r\n\thost(host) {\r\n\t\tthis.#host = host;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Defines the port to use in the url to be build\r\n\t * @param port String or number with the port\r\n\t * @returns Fluent instance to continue the build\r\n\t */\r\n\tport(port) {\r\n\t\tvar portType = typeof (port);\r\n\t\tif (portType === 'string') {\r\n\t\t\tthis.#port = port;\r\n\t\t} else if (portType === 'number') {\r\n\t\t\tthis.#port = String(port);\r\n\t\t} else {\r\n\t\t\tthrow new Error('alux.http.url_builder.invalid_port');\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Defines the base path to set in the url to be build\r\n\t * @param path String with the base path to use\r\n\t * @returns Fluent instance to continue the build\r\n\t */\r\n\tpath(path) {\r\n\t\tthis.#path = path;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a new url instance based on the arguments collected by this builder instance\r\n\t * @returns Instance representing the Url\r\n\t */\r\n\tbuild() {\r\n\t\treturn new AluxUrl(this.#protocol, this.#host, this.#port, this.#path);\r\n\t}\r\n}\r\n\r\n/**\r\n * Allows to obtain a builder to create an url\r\n * @returns Instance of the url builder\r\n */\r\n$module.url = function () {\r\n\treturn new UrlBuilder();\r\n};\r\n\r\nexport default $module;","const $moduleName = 'alux.controller';\r\nconst $scope = {};\r\n// contains all the controllers registered, indexed by name\r\n$scope.controllers = {};\r\n\r\nimport http from './http.mjs';\r\nimport errorHandler from './errorHandler.mjs'; \r\nimport log from './logging.mjs';\r\nconst logger = log.getLogger($moduleName);\r\n\r\n/** Allows to obtain a specific controller */\r\nconst $module = function (name) {\r\n    if (typeof(name) === 'string') {\r\n        var controller = $scope.controllers[name];\r\n        if(!controller) {\r\n            throw new Error('alux.controller.unknown_controller[' + name + ']');\r\n        }\r\n        return controller;\r\n    }\r\n};\r\n\r\n/** Class with the implementation of a controller object */\r\nclass AluxController {\r\n    // name to identify the controller\r\n    #name;\r\n    // controller implementation source\r\n    #impl;\r\n    constructor(name, impl) {\r\n        this.#name = name;\r\n        this.#impl = impl;\r\n    }\r\n\r\n    /** Allows to obtain the name of the controller */\r\n    get name() {\r\n        return this.#name;\r\n    }\r\n\r\n    declare(impl) {\r\n        if(typeof(impl) !== 'function') {\r\n            throw new Error('alux.controller.declare.invalid_implementation[' + this.#name + ']');\r\n        }\r\n        this.#impl = impl;\r\n    }\r\n\r\n    /**\r\n     * Serves the controller\r\n     * @returns Promise fullfilled once the controller has been executed\r\n     */\r\n    serve() {\r\n        var implType = typeof(this.#impl);\r\n        if(implType === 'function') {\r\n            logger.debug('Serving controller. controller=' + this.#name);\r\n            return new Promise((resolve, reject) => {\r\n                try {\r\n                    this.#impl();\r\n                    resolve();\r\n                } catch(err) {\r\n                    reject(errorHandler.create({\r\n                        module: $moduleName, \r\n                        cause: err,\r\n                        code: 'alux.controller.serve.implementation_error[' + this.#name + ']'  \r\n                    }));\r\n                }\r\n            });\r\n        } else if(implType === 'string') {\r\n            logger.debug('Loading controller. controller=' + this.#name);\r\n            return new Promise((resolve, reject) => {\r\n                http.loadScript(this.#impl).then(() => {\r\n                    setTimeout(() => {\r\n                        $module(this.#name).serve().then(resolve).catch(reject);\r\n                    }, 0);\r\n                }).catch((err) => {\r\n                    reject(errorHandler.create({\r\n                        module: $moduleName, \r\n                        cause: err,\r\n                        code: 'alux.controller.load_script_error[' + this.#name + ']'  \r\n                    }));\r\n                });\r\n            });\r\n        }\r\n        return Promise.reject(errorHandler.create({\r\n            module: $moduleName, \r\n            code: 'alux.controller.bad_implementation[' + this.#name + ']'  \r\n        }))\r\n    }\r\n}\r\n\r\n/**\r\n * Registers a new controller\r\n * @param name Controller name\r\n * @param impl String with the controller implementation source or function with the behavior to execute\r\n */\r\n$module.register = function (name, impl) {\r\n    logger.debug('Registering controller. controller=' + name);\r\n    var controller = new AluxController(name, impl);\r\n    $scope.controllers[name] = controller;\r\n    return controller;\r\n};\r\n\r\n/**\r\n * Declares the implementation of a specific controller\r\n * @param name Name of the controller to declare\r\n * @param impl Implementation to declare\r\n */\r\n$module.declare = function(name, impl) {\r\n    logger.debug('Declaring controller. controller=' + name);\r\n    var controller = $scope.controllers[name];\r\n    if(!controller) {\r\n        throw new Error('alux.controller.declare.unknown_controller[' + name +']');\r\n    }\r\n    controller.declare(impl);\r\n};\r\n\r\n/**\r\n * Allows to determine if a particular object is a controller\r\n * @param obj Object instance to evaluate\r\n * @returns Boolean value to determine if the object is a controller or not\r\n */\r\n $module.isController = function(obj) {\r\n    return (obj && obj instanceof AluxController);\r\n};\r\n\r\nexport default $module;","const $moduleName = 'alux.fragment';\r\nconst $scope = {};\r\n$scope.fragments = {};\r\n\r\nimport http from './http.mjs';\r\nimport errorHandler from './errorHandler.mjs';\r\nimport controller from './controller.mjs';\r\nimport util from './util.mjs';\r\nimport log from './logging.mjs';\r\nconst logger = log.getLogger($moduleName);\r\n\r\n/** Class with the implementation of a fragment object */\r\nclass AluxFragment {\r\n    // name to identify the fragment\r\n    #name;\r\n    // url with the content source\r\n    #source;\r\n    // name of the controller used by the fragment\r\n    #controller;\r\n    constructor(name, source, controller) {\r\n        this.#name = name;\r\n        this.#source = source;\r\n        this.#controller = controller;\r\n    }\r\n\r\n    /** Allows to obtain the name of the fragment */\r\n    get name() {\r\n        return this.#name;\r\n    }\r\n\r\n    #runController() {\r\n        return new Promise((resolve, reject) => {\r\n            if (!this.#controller) {\r\n                resolve();\r\n            } else {\r\n                setTimeout(() => {\r\n                    var controllerType = typeof (this.#controller);\r\n                    if (controllerType === 'function') {\r\n                        logger.debug('Serving fragment controller function. fragment=' + this.#name);\r\n                        try {\r\n                            this.#controller();\r\n                            resolve();\r\n                        } catch (err) {\r\n                            reject(errorHandler.create({\r\n                                module: $moduleName,\r\n                                cause: err,\r\n                                code: 'alux.fragment.controller_implementation_error[' + this.#name + ']'\r\n                            }));\r\n                        }\r\n                    } else if (controllerType === 'string') {\r\n                        logger.debug('Serving fragment controller. fragment=' + this.#name + ' controller=' + this.#controller);\r\n                        controller(this.#controller).serve().then(resolve).catch((err) => {\r\n                            reject(errorHandler.create({\r\n                                module: $moduleName,\r\n                                cause: err,\r\n                                code: 'alux.fragment.controller_serve_error[' + this.name + ']'\r\n                            }));\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Serves the fragment rendering its content in a specific placeholder\r\n     * @param selector String with the selector to identify the target placeholder or reference to the DOM element\r\n     * @param handled Boolean value to determine if a promise should be returned to handle the actions after serving the promise and the errors.\r\n     *          By default it is false.  When is not handled the framework will take care of the errors in an standard way by rendering an\r\n     *          error badge into the target selector.\r\n     * @returns Promise to take actions depending on the result of the rendering. The promise receives a context that contains\r\n     *          two attributes:\r\n     *          - target: Reference to the DOM element that will receive the fragment content\r\n     *          - response: Fragment content received as part of tha AJAX call.  This can be replaced by a different output.\r\n     */\r\n    serve(selector, handled) {\r\n        var target = util.element(selector);\r\n        if (target.count === 0) {\r\n            return Promise.reject(errorHandler.create({\r\n                module: $moduleName,\r\n                code: 'alux.fragment.serve.target_not_found[' + selector + ']'\r\n            }));\r\n        }\r\n        logger.debug('Serving fragment. fragment=' + this.#name);\r\n        const loadFragment = (resolve, reject) => {\r\n            http.request(this.#source, { method: 'GET' }).then((response) => {\r\n                // TODO: add a response interceptor\r\n                setTimeout(() => {\r\n                    target.html(response);\r\n                    this.#runController().then(resolve).catch(reject);\r\n                }, 0);\r\n            }).catch((err) => {\r\n                reject(errorHandler.create({\r\n                    module: $moduleName,\r\n                    message: 'An error has occurred trying to load a fragment of content',\r\n                    cause: err,\r\n                    code: 'alux.fragment.serve_error[' + this.name + ']'\r\n                }));\r\n            });\r\n        }\r\n        if(handled === true) {\r\n            return new Promise((resolve, reject) => {\r\n                loadFragment(resolve, reject);\r\n            });\r\n        }\r\n        loadFragment(() => {\r\n        }, (err) => {\r\n            errorHandler.render(target, err);\r\n        })\r\n    }\r\n}\r\n\r\n/** Allows to obtain a specific fragment */\r\nconst $module = function (name) {\r\n    if (typeof (name) === 'string') {\r\n        var fragment = $scope.fragments[name];\r\n        if (!fragment) {\r\n            throw new Error('alux.fragment.unknown_fragment[' + name + ']');\r\n        }\r\n        return fragment;\r\n    }\r\n};\r\n\r\n/**\r\n * Registers a new fragment\r\n * @param name Fragment name\r\n * @param source Fragment content\r\n * @param controller Optional name of the controller associated with the fragment\r\n */\r\n$module.register = function (name, source, controller) {\r\n    logger.debug('Registering fragment. fragment=' + name);\r\n    var fragment = new AluxFragment(name, source, controller);\r\n    $scope.fragments[name] = fragment;\r\n    return fragment;\r\n};\r\n\r\n/**\r\n * Allows to determine if a particular object is a fragment\r\n * @param obj Object instance to evaluate\r\n * @returns Boolean value to determine if the object is a fragment or not\r\n */\r\n$module.isFragment = function(obj) {\r\n    return (obj && obj instanceof AluxFragment);\r\n};\r\n\r\nexport default $module;","const $module = {};\r\nconst $moduleName = 'alux.router';\r\nconst $scope = {};\r\n// contains all the routes registered\r\n$scope.routes = [];\r\n// holds the reference to the default route if any\r\n$scope.defaultRoute = null;\r\n// holds the reference to the route that will be served when there is not default route and a pattern is not matched\r\n$scope.notFoundRoute = null;\r\n// Reference to the target element that receives the routing of fragments\r\n$scope.target = null;\r\n\r\nimport util from './util';\r\nimport fragment from './fragment';\r\nimport errorHandler from './errorHandler';\r\nimport log from './logging';\r\nconst logger = log.getLogger($moduleName);\r\n\r\n/**\r\n * Internal control method that is invoked when the hash receives a change\r\n * @param eventName String with the name of the event that triggered the change (mostly for tracing purposes)\r\n */\r\nfunction onHashChange(eventName) {\r\n    logger.debug('Hash change triggered. event=' + eventName);\r\n    const hash = $module.hash();\r\n    var route = $module.match(hash);\r\n    if (route) {\r\n        logger.debug('Serving route: ' + route.pattern);\r\n    } else if ($scope.defaultRoute && (!hash || !$scope.notFoundRoute)) {\r\n        if (hash) {\r\n            logger.warn('Route not found. Serving default hash=' + hash);\r\n        } else {\r\n            logger.debug('No hash found. Serving default router');\r\n        }\r\n        route = $scope.defaultRoute;\r\n    } else if ($scope.notFoundRoute) {\r\n        // TODO: define actions when there is no matching route and default hash is not defined\r\n        logger.warn('Route not found. hash=' + hash + ' route=' + $scope.notFoundRoute.pattern);\r\n        route = $scope.notFoundRoute;\r\n    } else {\r\n        errorHandler.render({\r\n            module: $moduleName,\r\n            message: 'The requested resource was not found: ' + hash,\r\n            code: 'alux.router.no_matching_no_default'\r\n        });\r\n        return;\r\n    }\r\n    route.serve(hash);\r\n}\r\n\r\n/**\r\n * Class representing a hash that allows to parse it and evaluate its parts\r\n */\r\nclass RouteHash {\r\n    #pattern\r\n    #parts\r\n    #parameters\r\n\r\n    constructor(pattern) {\r\n        if (!pattern || typeof (pattern) !== 'string') {\r\n            throw Error('alux.router.hah.invalid_pattern');\r\n        }\r\n        this.#pattern = pattern;\r\n        this.#parse();\r\n    }\r\n\r\n    #parse() {\r\n        this.#parts = [];\r\n        this.#parameters = [];\r\n        var parts = this.#pattern.split('/');\r\n        for (var idx = 0; idx < parts.length; idx++) {\r\n            var section = parts[idx];\r\n            if(section.startsWith(':')) {\r\n                this.#parameters.push(section.substr(1));\r\n            }\r\n            this.#parts.push(section);\r\n        }\r\n    }\r\n\r\n    get pattern() {\r\n        return this.#pattern;\r\n    }\r\n\r\n    get count() {\r\n        return this.#parts.length;\r\n    }\r\n\r\n    get hasParameters() {\r\n        return this.#parameters.length > 0;\r\n    }\r\n}\r\n\r\n/**\r\n * Class representing a route definition\r\n */\r\nclass AluxRoute {\r\n    // Object representing the router hash pattern\r\n    #routeHash\r\n    // Action to be executed when the route is executed\r\n    #action\r\n\r\n    /**\r\n     * Creates an object with the router specifications\r\n     * @param pattern String with the hash pattern to use for this router\r\n     * @param action Function with the action to execute or reference to a fragment or a controller\r\n     */\r\n    constructor(pattern, action) {\r\n        if (!pattern || typeof (pattern) !== 'string') {\r\n            throw new Error('alux.route.constructor.invalid_route_value');\r\n        } else if (!action) {\r\n            throw new Error('alux.route.constructor.missing_route_action');\r\n        }\r\n        this.#routeHash = new RouteHash(pattern);\r\n        this.#action = action;\r\n    }\r\n\r\n    get pattern() {\r\n        return this.#routeHash.pattern;\r\n    }\r\n\r\n    asDefault() {\r\n        $scope.defaultRoute = this;\r\n    }\r\n\r\n    asNotFound() {\r\n        $scope.notFoundRoute = this;\r\n    }\r\n\r\n    match(hash) {\r\n        if (!this.#routeHash.hasParameters) {\r\n            return hash === this.#routeHash.pattern;\r\n        }\r\n        // QUEDE AQUI IMPLEMENTANDO EL ALGORITMO DE HASHING\r\n        return false;\r\n    }\r\n\r\n    serve(hash) {\r\n        if (typeof (this.#action) === 'function') {\r\n            try {\r\n                this.#action(hash);\r\n            } catch (err) {\r\n                logger.error('alux.router.action_error[' + this.pattern + '|' + hash + ']', err);\r\n            }\r\n        } else if (fragment.isFragment(this.#action)) {\r\n            this.#action.serve($scope.target);\r\n        } else if (typeof (this.#action.serve) === 'function') {\r\n            this.#action.serve();\r\n        } else {\r\n            throw Error('aux.route.invalid_action[' + this.pattern + ']');\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Registers a route into the routing engine\r\n * @param pattern String with the path used for the route\r\n * @param action Function to be invoked when the route is executed, or reference to the fragment or the controller to be executed\r\n */\r\n$module.register = function (pattern, action) {\r\n    logger.debug('Registering route. pattern=' + pattern);\r\n    var route = new AluxRoute(pattern, action);\r\n    $scope.routes.push(route);\r\n    return route;\r\n};\r\n\r\n/**\r\n * Search for the route that matches a specific route value\r\n * @param route String with the route path to match\r\n * @returns Route instance that matches the path or null if nothing matches the path\r\n */\r\n$module.match = function (hash) {\r\n    if (!hash || typeof (hash) !== 'string') {\r\n        return null;\r\n    }\r\n    for (var idx = 0; idx < $scope.routes.length; idx++) {\r\n        var route = $scope.routes[idx];\r\n        if (route.match(hash) === true) {\r\n            return route;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\n/**\r\n * Obtains the current hash\r\n * @returns Current hash value in the location\r\n */\r\n$module.hash = function () {\r\n    var hash = window.location.hash;\r\n    if (hash.startsWith('#')) {\r\n        hash = hash.substr(1);\r\n    }\r\n    return hash;\r\n}\r\n\r\n/**\r\n * Initializes the execution of the routing engine\r\n */\r\n$module.start = function () {\r\n    logger.debug('Starting Alux router');\r\n    util.events.addListener(window, 'hashchange', () => {\r\n        onHashChange('hashchange');\r\n    });\r\n    util.events.addListener(window, 'popstate', () => {\r\n        onHashChange('popstate');\r\n        return false;\r\n    });\r\n    util.events.onReady(() => {\r\n        onHashChange('routerstart');\r\n    });\r\n    return $module;\r\n};\r\n\r\n/**\r\n * Gets or sets the target element that will receive the content of any route associated with a fragment.  This method\r\n * is polymorphic. When no argument is provided returns the current target.\r\n * @param selector String with the selector of the target or reference to the DOM element that will receive the\r\n *                  content of any route that contains a fragment. When this is not provided the method will return\r\n *                  the selected target.\r\n * @returns When no selector is provided this method returns the defined target.\r\n */\r\n$module.target = function () {\r\n    if (arguments.length === 0) {\r\n        if (!$scope.target) {\r\n            return document.body;\r\n        }\r\n        return $scope.target;\r\n    }\r\n    var selector = arguments[0];\r\n    if (!selector) {\r\n        $scope.target = document.body;\r\n        return $module;\r\n    }\r\n    $scope.target = util.element(selector);\r\n    if (!$scope.target) {\r\n        logger.error('alux.router.target_not_found[' + selector + ']');\r\n        $scope.target = document.body;\r\n    }\r\n    return $module;\r\n};\r\n\r\nexport default $module;","const $module = {};\r\nconst $scope = {};\r\n$scope.styles = {};\r\n$scope.styles['info'] = { title: 'Information', icon: '', color: {} }\r\n\r\nfunction renderToast() {\r\n    const style = arguments[0];\r\n    const specs =  { title: null, message: null, icon: null, color: { border: null, background: null, text: null }};\r\n    if(arguments.length === 2) {\r\n        specs.message = arguments[1];\r\n    } else if(arguments.length === 3) {\r\n        specs.title = arguments[1];\r\n        specs.message = arguments[2];\r\n    }\r\n    console.log(style, arguments);\r\n}\r\n\r\n$module.info = function() {\r\n    renderToast('info', ...arguments);\r\n}\r\n\r\nexport default $module;\r\n","import toast from './toast';\r\n\r\nexport default { toast };","'use strict';\r\n\r\nconst $scope = {};\r\n$scope.version = { major: 1, minor: 0, patch: 0 };\r\nconsole.log('%cAlux Framework ' + version(), 'color: #64dd17;');\r\n\r\n/**\r\n * Allows to obtain the current framework version.  If a boolean true is passed as an argument then a \r\n * canonical represenration of the version will be produced.\r\n * @returns Version number as a string or canonical (as an object)\r\n */\r\nexport function version() {\r\n    if(arguments.length === 1 && arguments[0] === true) {\r\n        return {\r\n            major: $scope.version.major,\r\n            minor: $scope.version.minor,\r\n            patch: $scope.version.patch\r\n        };\r\n    }\r\n    return 'v' + $scope.version.major + '.' + $scope.version.minor + '.' + $scope.version.patch;\r\n};\r\n\r\nimport log from './logging';\r\nimport util from './util';\r\nimport cookies from './cookies';\r\nimport http from './http';\r\nimport controller from './controller';\r\nimport fragment from './fragment';\r\nimport router from './router';\r\nimport errorHandler from './errorHandler';\r\nimport ui from './components/ui';\r\n\r\n/**\r\n * Adds a function to be executed when the framework has completed the loading process\r\n * @param fnc Function to be invoked once the framework is ready\r\n */\r\nexport function ready(fnc) {\r\n    util.events.onReady(fnc);\r\n};\r\n\r\n/**\r\n * Captures an unhandled promise and process any error rendering it to the UI and logging the cause\r\n * @param promise Promise to handle\r\n */\r\nexport function handle(promise) {\r\n    if(!util.isPromise(promise)) {\r\n        throw Error('alux.handle_promise.invalid_promise');\r\n    }\r\n    promise.catch((err) => {\r\n        errorHandler.render(err);\r\n    });\r\n};\r\n\r\nexport { log, util, cookies, http, controller, fragment, router, errorHandler, ui };"],"names":["$module","$scope","AluxElement","element","this","Array","isArray","_classPrivateFieldGet","length","arguments","innerHTML","content","html","eventName","fnc","Error","events","addListener","selector","singletons","body","document","window","selectorType","querySelector","ready","completed","listeners","checkReadyState","onReady","eventHolder","push","onEvent","onDocumentReady","map","handler","readyState","addEventListener","attachEvent","target","isPromise","Promise","trim","text","replace","random","tinyId","Math","toString","substring","shortId","guid","name","value","timespan","expireDate","Date","setTime","getTime","cookie","util","toGMTString","cookieArray","split","idx","rawCookie","cookieParts","fatal","color","label","error","warn","info","debug","trace","levelCookie","cookies","get","log","logName","currentLevel","level","message","details","console","globalLevel","levels","Logger","levelInfo","set","getLogger","loggers","logger","_$scope$globalLevel","ErrorHandler","specs","cause","module","code","HttpError","create","render","err","createHttpError","httpCode","createRequest","resolve","reject","request","XMLHttpRequest","ActiveXObject","e","ex","createXmlHttp","onreadystatechange","status","responseText","errorHandler","url","options","method","open","async","data","send","loadScript","createElement","src","type","onerror","onload","head","appendChild","AluxUrl","protocol","host","port","path","query","hash","endsWith","startsWith","resourceUrl","UrlBuilder","portType","String","$moduleName","controller","controllers","AluxController","impl","implType","_this","http","then","setTimeout","serve","register","declare","isController","obj","AluxFragment","source","handled","count","loadFragment","response","_this2","controllerType","fragment","fragments","isFragment","onHashChange","route","match","pattern","defaultRoute","notFoundRoute","RouteHash","parts","section","substr","AluxRoute","action","hasParameters","routes","location","start","renderToast","style","styles","title","icon","toast","version","major","minor","patch","promise"],"mappings":"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"}